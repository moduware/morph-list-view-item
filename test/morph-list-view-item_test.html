<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">

    <title>morph-list-view-item test</title>

    <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../web-component-tester/browser.js"></script>
    <script src="../../chai-dom/chai-dom.js"></script>

    <link rel="import" href="/bower_components/polymer/lib/utils/flattened-nodes-observer.html">

    <link rel="import" href="../morph-list-view-item.html">
  </head>
  <body>

    <test-fixture id="IosBasicTestFixture">
      <template>
        <morph-list-view-item platform="ios">
          <span id="title" slot="header">Header</span>
          Item 1
          <span slot="footer">Footer</span>
          <span slot="secondary-content">Secondary Content</span>
        </morph-list-view-item>
      </template>
    </test-fixture>

    <test-fixture id="AndroidBasicTestFixture">
      <template>
        <morph-list-view-item platform="android">
          <span id="title" slot="header">Header</span>
          Item 1
          <span slot="footer">Footer</span>
          <span slot="secondary-content">Secondary Content</span>
        </morph-list-view-item>
      </template>
    </test-fixture>

    <test-fixture id="ChevronTestFixture">
      <template>
        <morph-list-view-item platform="ios" href="#moduware">
          <span id="title" slot="header">Header</span>
          Link Item
          <span slot="footer">Footer</span>
          <span slot="secondary-content">Secondary Content</span>
        </morph-list-view-item>
      </template>
    </test-fixture>

    <test-fixture id="NoChevronTestFixture">
      <template>
        <morph-list-view-item platform="ios" href="#moduware" no-chevron>
          No Chevron Link Item
        </morph-list-view-item>
      </template>
    </test-fixture>

    <test-fixture id="AndroidRippleTestFixture">
      <template>
        <morph-list-view-item platform="android" href="#moduware">
          Android Link Item
        </morph-list-view-item>
      </template>
    </test-fixture>

    <test-fixture id="IosRippleTestFixture">
      <template>
        <morph-list-view-item platform="ios" href="#moduware">
          IOS Link Item
        </morph-list-view-item>
      </template>
    </test-fixture>

    <test-fixture id="AndroidWithNoRippleTestFixture">
      <template>
        <morph-list-view-item platform="android" href="#moduware" no-ripple>
          Android Link Item with No Ripple
        </morph-list-view-item>
      </template>
    </test-fixture>

    <script>
      describe('morph-list-view-item', () => {

        context('Basic test for iOS', () => {

          // declare variable to be used between 'beforeAll' block and 'context' block or 'it' block
          let element, items, observer1;

          beforeEach(function () {
            element = fixture('IosBasicTestFixture');
            observer1 = new Polymer.FlattenedNodesObserver(element, function (info) {
              items = info;
            });
            observer1.flush();
          });

          afterEach(function () {
            observer1.disconnect();
          });

          it('shows slot="header" with text "Header"', () => {
            let nodes = items.addedNodes;
            for (var i = 0; i < nodes.length; i++) {
              if (nodes[i].nodeName != "#text") {
                var listViewItemChild = nodes[i];
                // check which item matches header slot name
                if (listViewItemChild.getAttribute('slot') == 'header') {
                  let elementHeader = listViewItemChild;
                  expect(elementHeader.innerHTML).to.equal('Header');
                }
              }
            }
          });

          it('shows slot="footer" with text "Footer"', () => {
            let nodes = items.addedNodes;
            for (var i = 0; i < nodes.length; i++) {
              if (nodes[i].nodeName != "#text") {
                var listViewItemChild = nodes[i];
                // check which item matches footer slot name
                if (listViewItemChild.getAttribute('slot') == 'footer') {
                  let elementFooter = listViewItemChild;
                  expect(elementFooter.innerHTML).to.equal('Footer');
                }
              }
            }
          });
        });


        context('Test for IOS styles', () => {

          // declare variable to be used between 'beforeAll' block and 'context' block or 'it' block
          let element, items, observer1;

          beforeEach(function() {
            element = fixture('IosBasicTestFixture');
            
            observer1 = new Polymer.FlattenedNodesObserver(element, function (info) {
              items = info;
            });
            observer1.flush();
          });

          it('Should have correct main-text font-size for IOS platform', () => {
            const itemMainText = element.shadowRoot.querySelector('div.main-text');
            const mainTextStyles = window.getComputedStyle(itemMainText);
            
            expect(mainTextStyles.fontSize).to.equal('17px');
          });

          it('Should have correct font-size and font-weight for IOS header', () => {
            let nodes = items.addedNodes;
            for (var i = 0; i < nodes.length; i++) {
              if (nodes[i].nodeName != "#text") {
                var listViewItemChild = nodes[i];
                // check which item matches header slot name 'header'
                if (listViewItemChild.getAttribute('slot') == 'header') {
                  let elementHeader = listViewItemChild;
                  let IosHeaderFontSize = window.getComputedStyle(elementHeader).getPropertyValue('font-size');
                  let IosHeaderFontWeight = window.getComputedStyle(elementHeader).getPropertyValue('font-weight');
                  
                  // 2 expectations for closely related checks is allowed. Otherwise one expect per 'it' block
                  expect(IosHeaderFontSize).to.equal('12px');
                  expect(IosHeaderFontWeight).to.equal('400');
                }
              }
            }
          });

          it('Should have correct font-size and color for IOS footer', () => {
            let nodes = items.addedNodes;

            for (var i = 0; i < nodes.length; i++) {
              if (nodes[i].nodeName != "#text") {
                var listViewItemChild = nodes[i];
                // check which item matches header slot name 'footer'
                if (listViewItemChild.getAttribute('slot') == 'footer') {
                  let elementFooter = listViewItemChild;
                  let IosFooterFontSize = window.getComputedStyle(elementFooter).getPropertyValue('font-size');
                  let IosFootererColor = window.getComputedStyle(elementFooter).getPropertyValue('color');
                  
                  // 2 expectations for closely related checks is allowed. Otherwise one expect per 'it' block
                  expect(IosFooterFontSize).to.equal('12px');
                  expect(IosFootererColor).to.equal('rgb(142, 142, 147)');
                }
              }
            }
          });

          it('Should have correct secondary-content color and font-size for IOS platform', () => {
            let nodes = items.addedNodes;
            
            for (var i = 0; i < nodes.length; i++) {
              // check which item matches header slot name 'secondary-content'
              if (nodes[i].nodeName != "#text") {
                var listViewItemChild = nodes[i];
                if (listViewItemChild.getAttribute('slot') == 'secondary-content') {
                  let elementSecondaryContent = listViewItemChild;
                  let IosSecondaryContentColor = window.getComputedStyle(elementSecondaryContent).getPropertyValue('color');
                  let IosSecondaryContentFontSize = window.getComputedStyle(elementSecondaryContent).getPropertyValue('font-size');

                  // 2 expectations for closely related checks is allowed. Otherwise one expect per 'it' block
                  expect(IosSecondaryContentColor).to.equal('rgb(142, 142, 147)');
                  expect(IosSecondaryContentFontSize).to.equal('17px');
                }
              }
            }
          });

        });

        context('Test for Android styles', () => {

          // declare variable to be used between 'beforeAll' block and 'context' block or 'it' block
          let element, items, observer1;

          beforeEach(function () {
            element = fixture('AndroidBasicTestFixture');
            
            observer1 = new Polymer.FlattenedNodesObserver(element, function (info) {
              items = info;
            });
            observer1.flush();
          });

          it('Should have correct main-text font-size for Android platform', () => {
            const itemMainText = element.shadowRoot.querySelector('div.main-text');
            const mainTextStyles = window.getComputedStyle(itemMainText);

            expect(mainTextStyles.fontSize).to.equal('16px');
          });

          it('Should have correct font-size and font-weight for Android header', () => {
            let nodes = items.addedNodes;

            for (var i = 0; i < nodes.length; i++) {
              if (nodes[i].nodeName != "#text") {
                var listViewItemChild = nodes[i];
                // check which item matches header slot name 'header'
                if (listViewItemChild.getAttribute('slot') == 'header') {
                  let elementHeader = listViewItemChild;
                  let AndroidHeaderFontSize = window.getComputedStyle(elementHeader).getPropertyValue('font-size');
                  let AndroidHeaderFontWeight = window.getComputedStyle(elementHeader).getPropertyValue('font-weight');

                  // 2 expectations for closely related checks is allowed. Otherwise one expect per 'it' block
                  expect(AndroidHeaderFontSize).to.equal('12px');
                  expect(AndroidHeaderFontWeight).to.equal('400');
                }
              }
            }
          });

          it('Should have correct font-size and color for Android footer', () => {
            let nodes = items.addedNodes;

            for (var i = 0; i < nodes.length; i++) {
              // check which item matches header slot name 'secondary-content'
              if (nodes[i].nodeName != "#text") {
                var listViewItemChild = nodes[i];
                if (listViewItemChild.getAttribute('slot') == 'footer') {
                  let elementFooter = listViewItemChild;
                  let AndroidSecondaryContentColor = window.getComputedStyle(elementFooter).getPropertyValue('color');
                  let AndroidSecondaryContentFontSize = window.getComputedStyle(elementFooter).getPropertyValue('font-size');

                  // 2 expectations for closely related checks is allowed. Otherwise one expect per 'it' block
                  expect(AndroidSecondaryContentColor).to.equal('rgb(142, 142, 147)');
                  expect(AndroidSecondaryContentFontSize).to.equal('12px');
                }
              }
            }
          });

          it('Should have correct secondary-content font-size and color Android platform', () => {
            let nodes = items.addedNodes;
            for (var i = 0; i < nodes.length; i++) {
              if (nodes[i].nodeName != "#text") {
                var listViewItemChild = nodes[i];
                // check which item matches header slot name 'secondary-content'
                if (listViewItemChild.getAttribute('slot') == 'secondary-content') {
                  let elementSecondaryContent = listViewItemChild;
                  let AndroidSecondaryContentFontSize = window.getComputedStyle(elementSecondaryContent).getPropertyValue('font-size');
                  let AndroidSecondaryContentColor = window.getComputedStyle(elementSecondaryContent).getPropertyValue('color');

                  // 2 expectations for closely related checks is allowed. Otherwise one expect per 'it' block
                  expect(AndroidSecondaryContentFontSize).to.equal('14px');
                  expect(AndroidSecondaryContentColor).to.equal('rgb(117, 117, 117)');
                }
              }
            }
          });

          //  TODO:
          it('Should have no ripple', (done) => {
            shadowRoot = element.shadowRoot;
            container = shadowRoot.querySelector('.container');
            morphRipple = container.getElementsByTagName('morph-ripple');

            // flush function needed to make sure dynamically-rendered elements in polymer like 'dom-if' are rendered and ready
            flush(function () {
              expect(morphRipple.length).to.equal(0);
              done();
            });
          });

        });

      }); // end of describe 'morph-list-view-item'
      
      describe('Test for Chevron child element', () => {

        context('Chevron when it is a link item (href present)', () => {
          // declare variable to be used between 'beforeAll' block and 'context' block or 'it' block
          let element;

          beforeEach(function () {
            element = fixture('ChevronTestFixture');
          });

          it('Should have noChevron property equal to false', () => {
            expect(element.noChevron).to.be.false;
          });

          it('Should have chevron svg css display property equal to block', (done) => {
            const shadowRoot = element.shadowRoot;
            const subContainer = shadowRoot.querySelector('.sub-container');
            const chevronSvg = subContainer.getElementsByTagName('svg');

            // flush function needed to make sure dynamically-rendered elements in polymer like 'dom-if' are rendered and ready
            flush(function () {
              const chevronDisplay = window.getComputedStyle(chevronSvg[0]).getPropertyValue('display');

              expect(chevronSvg.length).to.equal(1);
              expect(chevronDisplay).to.equal('block');
              done();
            });

          });

        });

        context('Chevron when no-chevron attribute is present', () => {
          // declare variable to be used between 'beforeAll' block and 'context' block or 'it' block
          let element;

          beforeEach(function () {
            element = fixture('NoChevronTestFixture');
          });


          it('Should have noChevron property equal to true', () => {
            expect(element.noChevron).to.be.true;
          });

          it('Should have chevron svg css display property equal to block', (done) => {
            const shadowRoot = element.shadowRoot;
            const subContainer = shadowRoot.querySelector('.sub-container');
            const chevronSvg = subContainer.getElementsByTagName('svg');

            // flush function needed to make sure dynamically-rendered elements in polymer like 'dom-if' are rendered and ready
            flush(function () {
              expect(chevronSvg.length).to.equal(0);
              done();
            });

          });

        });


      }); // end of describe 'Test for Chevron child element'
     
     describe('morph-ripple child element', () => {

      context('when on android', () => {
        let element, shadowRoot, container, morphRipple;

        before(function() {
          element = fixture('AndroidRippleTestFixture');
          shadowRoot = element.shadowRoot;
          container = shadowRoot.querySelector('.container');
          morphRipple = container.getElementsByTagName('morph-ripple');
        });

        it('Should have display block', (done) => {
          
          // flush function needed to make sure dynamically-rendered elements in polymer like 'dom-if' are rendered and ready
          flush(function () {
            const morphRippleDisplay = window.getComputedStyle(morphRipple[0]).getPropertyValue('display');
            
            expect(morphRipple.length).to.equal(1);
            expect(morphRippleDisplay).to.equal('block');
            done();
          });
        });

      });

      context('when on ios', () => {
        let element, shadowRoot, container, morphRipple;

        beforeEach(function () {
          element = fixture('IosRippleTestFixture');
          shadowRoot = element.shadowRoot;
          container = shadowRoot.querySelector('.container');
          morphRipple = container.getElementsByTagName('morph-ripple');
        });

        it('Should have display none', (done) => {

          // flush function needed to make sure dynamically-rendered elements in polymer like 'dom-if' are rendered and ready
          flush(function () {
            const morphRippleDisplay = window.getComputedStyle(morphRipple[0]).getPropertyValue('display');

            expect(morphRippleDisplay).to.equal('none');
            done();
          });
        });

      });

      context('when no-ripple attribute is present', () => {
        let element, shadowRoot, container, morphRipple;

        beforeEach(function () {
          element = fixture('AndroidWithNoRippleTestFixture');
          shadowRoot = element.shadowRoot;
          container = shadowRoot.querySelector('.container');
          morphRipple = container.getElementsByTagName('morph-ripple');
        });

        it('Should not exist in DOM', (done) => {

          // flush function needed to make sure dynamically-rendered elements in polymer like 'dom-if' are rendered and ready
          flush(function () {
            expect(morphRipple.length).to.equal(0);
            done();
          });
        });

      });

     }); // end of describe 'morph-ripple child element'

    </script>

  </body>
</html>
