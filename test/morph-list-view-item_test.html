<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">

    <title>morph-list-view-item test</title>

    <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../web-component-tester/browser.js"></script>
    <script src="../../chai-dom/chai-dom.js"></script>

    <link rel="import" href="/bower_components/polymer/lib/utils/flattened-nodes-observer.html">

    <link rel="import" href="../morph-list-view-item.html">
  </head>
  <body>

    <test-fixture id="IosBasicTestFixture">
      <template>
        <morph-list-view-item platform="ios">
          <span id="title" slot="header">Header</span>
          Item 1
          <span slot="footer">Footer</span>
          <span slot="secondary-content">Secondary Content</span>
        </morph-list-view-item>
      </template>
    </test-fixture>

    <test-fixture id="AndroidBasicTestFixture">
      <template>
        <morph-list-view-item platform="android">
          <span id="title" slot="header">Header</span>
          Item 1
          <span slot="footer">Footer</span>
          <span slot="secondary-content">Secondary Content</span>
        </morph-list-view-item>
      </template>
    </test-fixture>

    <script>
      describe('morph-list-view-item', () => {

        context('Basic test for iOS', () => {

          // declare variable to be used between 'beforeAll' block and 'context' block or 'it' block
          let element, items, observer1;

          beforeEach(function () {
            element = fixture('IosBasicTestFixture');
            observer1 = new Polymer.FlattenedNodesObserver(element, function (info) {
              items = info;
            });
            observer1.flush();
          });

          afterEach(function () {
            observer1.disconnect();
          });

          it('shows slot="header" with text "Header"', () => {
            let nodes = items.addedNodes;
            for (var i = 0; i < nodes.length; i++) {
              if (nodes[i].nodeName != "#text") {
                var tabbarItem = nodes[i];
                // check which item matches header slot name
                if (tabbarItem.getAttribute('slot') == 'header') {
                  console.log('tabbarItem', tabbarItem.innerHTML);
                  let elementHeader = tabbarItem;
                  expect(elementHeader.innerHTML).to.equal('Header');
                }
              }
            }
          });

          it('shows slot="footer" with text "Footer"', () => {
            let nodes = items.addedNodes;
            for (var i = 0; i < nodes.length; i++) {
              if (nodes[i].nodeName != "#text") {
                var tabbarItem = nodes[i];
                // check which item matches footer slot name
                if (tabbarItem.getAttribute('slot') == 'footer') {
                  console.log('tabbarItem', tabbarItem.innerHTML);
                  let elementFooter = tabbarItem;
                  expect(elementFooter.innerHTML).to.equal('Footer');
                }
              }
            }
          });
        });


        context('Test for IOS styles', () => {

          // declare variable to be used between 'beforeAll' block and 'context' block or 'it' block
          let element, items, observer1;

          beforeEach(function() {
            element = fixture('IosBasicTestFixture');
            
            observer1 = new Polymer.FlattenedNodesObserver(element, function (info) {
              items = info;
            });
            observer1.flush();
          });

          it('Should have correct main-text font-size for IOS platform', () => {
            const itemMainText = element.shadowRoot.querySelector('div.main-text');
            const mainTextStyles = window.getComputedStyle(itemMainText);
            
            expect(mainTextStyles.fontSize).to.equal('17px');
          });

          it('Should have correct font-size and font-weight for IOS header', () => {});
          it('Should have correct font-size and color for IOS footer', () => {});

          it('Should have correct secondary-content color and font-size for IOS platform', () => {
            let nodes = items.addedNodes;
            
            for (var i = 0; i < nodes.length; i++) {
              // check which item matches header slot name 'secondary-content'
              if (nodes[i].nodeName != "#text") {
                var tabbarItem = nodes[i];
                if (tabbarItem.getAttribute('slot') == 'secondary-content') {
                  let elementSecondaryContent = tabbarItem;
                  let IosSecondaryContentColor = window.getComputedStyle(elementSecondaryContent).getPropertyValue('color');
                  let IosSecondaryContentFontSize = window.getComputedStyle(elementSecondaryContent).getPropertyValue('font-size');

                  // 2 expectations for closely related checks is allowed. Otherwise one expect per 'it' block
                  expect(IosSecondaryContentColor).to.equal('rgb(142, 142, 147)');
                  expect(IosSecondaryContentFontSize).to.equal('17px');
                }
              }
            }
          });


        });

        context('Test for Android styles', () => {

          // declare variable to be used between 'beforeAll' block and 'context' block or 'it' block
          let element, items, observer1;

          beforeEach(function () {
            element = fixture('AndroidBasicTestFixture');
            
            observer1 = new Polymer.FlattenedNodesObserver(element, function (info) {
              items = info;
            });
            observer1.flush();
          });

          it('Should have correct main-text font-size for Android platform', () => {
            const itemMainText = element.shadowRoot.querySelector('div.main-text');
            const mainTextStyles = window.getComputedStyle(itemMainText);

            expect(mainTextStyles.fontSize).to.equal('16px');
          });

          it('Should have correct font-size and font-weight for Android header', () => { });
          it('Should have correct font-size and color for Android footer', () => { });

          it('Should have correct secondary-content font-size and color Android platform', () => {
            let nodes = items.addedNodes;
            for (var i = 0; i < nodes.length; i++) {
              if (nodes[i].nodeName != "#text") {
                var tabbarItem = nodes[i];
                // check which item matches header slot name 'secondary-content'
                if (tabbarItem.getAttribute('slot') == 'secondary-content') {
                  let elementSecondaryContent = tabbarItem;
                  let AndroidSecondaryContentFontSize = window.getComputedStyle(elementSecondaryContent).getPropertyValue('font-size');
                  let AndroidSecondaryContentColor = window.getComputedStyle(elementSecondaryContent).getPropertyValue('color');

                  expect(AndroidSecondaryContentFontSize).to.equal('14px');
                  expect(AndroidSecondaryContentColor).to.equal('rgb(117, 117, 117)');
                }
              }
            }
          });
        });

      });
    </script>

  </body>
</html>
