<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">

    <title>morph-list-view-item test</title>

    <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../web-component-tester/browser.js"></script>
    <script src="../../chai-dom/chai-dom.js"></script>

    <link rel="import" href="/bower_components/polymer/lib/utils/flattened-nodes-observer.html">

    <link rel="import" href="../morph-list-view-item.html">
  </head>
  <body>

    <test-fixture id="IosBasicTestFixture">
      <template>
        <morph-list-view-item platform="ios">
          <span id="title" slot="header">Header</span>
          Item 3
          <span slot="footer">Footer</span>
        </morph-list-view-item>
      </template>
    </test-fixture>

    <script>
      describe('morph-list-view-item', () => {

        context('Basic test for iOS', () => {

          // declare variable to be used between 'beforeAll' block and 'context' block or 'it' block
          let element, items, observer1;

          beforeEach(function () {
            element = fixture('IosBasicTestFixture');
            observer1 = new Polymer.FlattenedNodesObserver(element, function (info) {
              items = info;
            });
            observer1.flush();
          });

          afterEach(function () {
            observer1.disconnect();
          });

          it('shows slot="header" with text "Header"', () => {
            let nodes = items.addedNodes;
            for (var i = 0; i < nodes.length; i++) {
              if (nodes[i].nodeName != "#text") {
                var tabbarItem = nodes[i];
                // check which item matches header slot name
                if (tabbarItem.getAttribute('slot') == 'header') {
                  console.log('tabbarItem', tabbarItem.innerHTML);
                  let elementHeader = tabbarItem;
                  expect(elementHeader.innerHTML).to.equal('Header');
                }
              }
            }
          });

          it('shows slot="footer" with text "Footer"', () => {
            let nodes = items.addedNodes;
            for (var i = 0; i < nodes.length; i++) {
              if (nodes[i].nodeName != "#text") {
                var tabbarItem = nodes[i];
                // check which item matches footer slot name
                if (tabbarItem.getAttribute('slot') == 'footer') {
                  console.log('tabbarItem', tabbarItem.innerHTML);
                  let elementFooter = tabbarItem;
                  expect(elementFooter.innerHTML).to.equal('Footer');
                }
              }
            }
          });
        });


        context('Test for IOS styles', () => {

          // declare variable to be used between 'beforeAll' block and 'context' block or 'it' block
          let element, items, observer1;

          beforeEach(function() {
            element = fixture('IosBasicTestFixture');
            styles = window.getComputedStyle(element);
          });

          it('IOS main-text font-size should be 17px', () => {
            const itemMainText = element.shadowRoot.querySelector('div.main-text');
            const mainTextStyles = window.getComputedStyle(itemMainText);
            
            expect(mainTextStyles.fontSize).to.equal('17px');
          });
        });

      });
    </script>

  </body>
</html>
